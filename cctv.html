<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>완성형 지능형 CCTV (객체/차량 추적 + ANPR + 거리측정)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- 라이브러리: TensorFlow(코코 SSD) + Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.9.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>

  <style>
    :root{--bg:#061424;--panel:#07202a;--accent:#7be6c9;--muted:#9fb;}
    body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#04111a,#071a23);color:#e6f7f9}
    .wrap{max-width:1100px;margin:10px auto;padding:12px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    header h1{margin:0;font-size:18px;color:#bff}
    .top{display:flex;gap:12px;flex-direction:column}
    .controls{background:var(--panel);padding:12px;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.35)}
    label{display:block;margin:8px 0;color:#cfe}
    select,input,button{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:#061a20;color:#e6f7f9}
    .row{display:flex;gap:8px}
    .row > *{flex:1}
    .small{width:auto;padding:8px}
    main{margin-top:12px;display:flex;flex-direction:column;gap:12px}
    /* 비디오 영역 */
    #viewer{background:#000;border-radius:8px;overflow:hidden;display:flex;justify-content:center;align-items:center;position:relative}
    video{width:100%;height:auto;display:block}
    canvas{position:absolute;left:0;top:0;pointer-events:none}
    /* 로그영역 */
    .log{background:var(--panel);padding:10px;border-radius:8px;color:#bfe;height:120px;overflow:auto}
    ul.plates{list-style:none;padding-left:10px;margin:6px 0}
    ul.plates li{margin:6px 0;color:#ffd66b}
    .note{font-size:12px;color:var(--muted);margin-top:8px}
    footer{margin-top:12px;color:#9fb;font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>지능형 CCTV — 통합판</h1>
      <div style="font-size:13px;color:#9fb">모드: 실시간 객체 인식 · 차량 추적 · 번호판(ANPR) · 거리근사</div>
    </header>

    <!-- 상단: 설정 / 로그 (요청: 상단에 UI) -->
    <div class="top">
      <div class="controls">
        <label>카메라 선택:
          <select id="cameraSelect"></select>
        </label>

        <div class="row">
          <div>
            <label>신뢰도 임계값 (0~1)
              <input id="threshold" type="number" min="0" max="1" step="0.05" value="0.5">
            </label>
          </div>
          <div>
            <label>FPS 제한
              <input id="fpsLimit" type="number" min="1" max="30" step="1" value="10">
            </label>
          </div>
        </div>

        <div class="row">
          <label style="flex:1"><input type="checkbox" id="showVehicleID" checked> 차량 ID 표시</label>
          <label style="flex:1"><input type="checkbox" id="plateMode"> 번호판 모드 사용</label>
        </div>

        <div class="row" style="margin-top:8px">
          <button id="snapshotBtn" class="small">스냅샷 저장(PNG)</button>
          <button id="downloadDetectionsBtn" class="small">탐지 로그 다운로드(.txt)</button>
        </div>

        <!-- 캘리브레이션: 거리 추정 보정용 -->
        <h3 style="color:#9ff;margin:10px 0 6px 0">거리 추정 캘리브레이션</h3>
        <label>실제 차량 평균 높이(미터) (예: 1.5)
          <input id="carHeight" type="number" min="0.5" step="0.1" value="1.5">
        </label>
        <div class="row">
          <div>
            <label>기준 거리(미터) 입력 (예: 5)
              <input id="knownDistance" type="number" min="0.5" step="0.1" value="5">
            </label>
          </div>
          <div style="display:flex;align-items:flex-end">
            <button id="calibrateBtn" class="small">캘리브레이션 캡처</button>
          </div>
        </div>
        <div class="note">캘리브레이션 방법: 화면에 보이는 기준 차량을 알려진 거리(예: 5m)에 위치시킨 뒤 '캘리브레이션 캡처'를 누르세요. 그러면 픽셀 -> 거리 변환 계수(초점거리)가 계산됩니다. (선택사항, 정확도 향상)</div>
      </div>

      <!-- 로그/인식결과 영역 -->
      <div class="log" id="logArea">
        <div><strong>현재 감지된 객체 (비디오 위 박스와 동일하게 표시됩니다)</strong></div>
        <div id="detectedList" style="margin-top:6px;color:#dff">(대기중)</div>

        <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:8px 0">

        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>FPS: <span id="fpsDisplay">0</span></div>
          <div>화면 내 차량 수: <span id="vehicleCount">0</span></div>
        </div>

        <h4 style="margin:8px 0 6px 0;color:#9ff">번호판 인식 (최근 5개)</h4>
        <ul class="plates" id="plateList"></ul>

        <div style="margin-top:6px;display:flex;gap:8px">
          <button id="downloadPlateLogBtn" class="small">번호판 로그 다운로드(.txt)</button>
          <button id="clearPlatesBtn" class="small">번호판 목록 초기화</button>
        </div>
      </div>
    </div>

    <!-- 하단: 카메라 화면 (요청: 카메라 하단 배치) -->
    <main>
      <div id="viewer" style="height:480px">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>
    </main>

    <footer>
      <div style="max-width:1100px;margin:10px auto;color:#9fb">
        • 권장: GitHub Pages 등 HTTPS 환경에서 실행하세요. / AppInventor WebView에서 동작시키려면 WebView의 getUserMedia 허용 설정이 필요합니다.
      </div>
    </footer>
  </div>

<script>
/* ============================
   완성형 CCTV 스크립트 (한국어 주석 포함)
   - COCO-SSD로 객체 인식
   - 차량 추적 (Centroid) + Vehicle ID
   - 차량이 있을 때만 거리(정수 m) 표시 (캘리브레이션 가능)
   - 번호판 모드: Tesseract(eng+kor) + 전처리 + 한국 판식 필터링
   - 카메라 선택/전환(페이지 새로고침 없이)
   - 최근 5개 번호판 저장/다운로드
   ============================ */

/* -------------------------
   DOM 요소 참조
   ------------------------- */
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');

const cameraSelect = document.getElementById('cameraSelect');
const thresholdInput = document.getElementById('threshold');
const fpsLimitInput = document.getElementById('fpsLimit');
const showIDCheckbox = document.getElementById('showVehicleID');
const plateModeCheckbox = document.getElementById('plateMode');
const snapshotBtn = document.getElementById('snapshotBtn');
const downloadDetectionsBtn = document.getElementById('downloadDetectionsBtn');

const detectedListDiv = document.getElementById('detectedList');
const fpsDisplay = document.getElementById('fpsDisplay');
const vehicleCountSpan = document.getElementById('vehicleCount');
const plateListUl = document.getElementById('plateList');

const downloadPlateLogBtn = document.getElementById('downloadPlateLogBtn');
const clearPlatesBtn = document.getElementById('clearPlatesBtn');
const calibrateBtn = document.getElementById('calibrateBtn');
const knownDistanceInput = document.getElementById('knownDistance');
const carHeightInput = document.getElementById('carHeight');

/* -------------------------
   모델/트acker/상태 변수
   ------------------------- */
let model = null;
let tesseractWorker = null;
let ocrBusy = false;

class CentroidTracker {
  constructor(maxDisappeared=30, maxDistance=120){
    this.nextObjectID = 0;
    this.objects = new Map(); // id -> { centroid, bbox, disappeared, lastOcrTime, plateText, minDistanceObserved }
    this.maxDisappeared = maxDisappeared;
    this.maxDistance = maxDistance;
  }
  register(centroid, bbox){
    this.objects.set(this.nextObjectID, { centroid, bbox, disappeared:0, lastOcrTime:0, plateText:null, minDistanceObserved:Infinity });
    this.nextObjectID++;
  }
  deregister(id){ this.objects.delete(id); }
  update(rects){
    if(rects.length === 0){
      for(const [id,obj] of this.objects){ obj.disappeared++; if(obj.disappeared > this.maxDisappeared) this.deregister(id); }
      return this.objects;
    }
    const inputCentroids = rects.map(r=>[r[0]+r[2]/2, r[1]+r[3]/2]);
    if(this.objects.size===0){
      rects.forEach((r,i)=>this.register(inputCentroids[i], r));
      return this.objects;
    }
    const objectIDs = Array.from(this.objects.keys());
    const objectCentroids = Array.from(this.objects.values()).map(o=>o.centroid);
    const D = objectCentroids.map(oc => inputCentroids.map(ic => Math.hypot(oc[0]-ic[0], oc[1]-ic[1])));
    const rows = D.map((row,i)=>({i,min:Math.min(...row)})).sort((a,b)=>a.min-b.min).map(r=>r.i);
    const usedCols = new Set(), usedRows = new Set();
    for(const rIndex of rows){
      const distances = D[rIndex];
      let bestCol=-1, bestDist=Infinity;
      for(let c=0;c<distances.length;c++){ if(usedCols.has(c)) continue; if(distances[c] < bestDist){ bestDist = distances[c]; bestCol = c; } }
      if(bestCol===-1) continue;
      if(bestDist > this.maxDistance) continue;
      const objectID = objectIDs[rIndex];
      const obj = this.objects.get(objectID);
      obj.centroid = inputCentroids[bestCol];
      obj.bbox = rects[bestCol];
      obj.disappeared = 0;
      obj.minDistanceObserved = Math.min(obj.minDistanceObserved, bestDist);
      usedCols.add(bestCol); usedRows.add(rIndex);
    }
    rects.forEach((r,i)=>{ if(!usedCols.has(i)) this.register(inputCentroids[i], r); });
    objectIDs.forEach((id,idx)=>{ if(!usedRows.has(idx)){ const obj=this.objects.get(id); obj.disappeared++; if(obj.disappeared>this.maxDisappeared) this.deregister(id); } });
    return this.objects;
  }
}
const tracker = new CentroidTracker(20, 140);

/* 기록용 */
let detectionsHistory = []; // 전체 탐지 기록 라인 문자열
let plateLog = []; // 최근 5개: {time, plate, id}

/* 거리추정 파라미터 (캘리브레이션에 의해 설정 가능) */
let focalPix = null; // 캘리브레이션으로 설정되면 사용 (픽셀 단위 focal)
let DEFAULT_K = 1500; // fallback 계수 (경험치) — 픽셀높이 기준: distance ≈ K / bboxHeight
// 사용자는 캘리브레이션 버튼으로 focalPix를 계산할 수 있음

/* 성능 제어 */
let lastFrameTime = 0;

/* -------------------------
   유틸 함수들
   ------------------------- */
// 스트림 안전 중지
function stopStreamTracks(stream){
  if(!stream) return;
  try{ stream.getTracks().forEach(t=>t.stop()); }catch(e){}
}

// 텍스트 파일 다운로드 유틸
function downloadTextFile(filename, text){
  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

/* -------------------------
   카메라 열거 및 시작 (페이지 새로고침 없이 전환)
   ------------------------- */
async function enumerateCameras(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d=>d.kind === 'videoinput');
    cameraSelect.innerHTML = '';
    if(cams.length===0){
      const opt = document.createElement('option'); opt.text = '카메라 없음'; cameraSelect.appendChild(opt);
    } else {
      cams.forEach((c,i)=>{
        const opt = document.createElement('option');
        opt.value = c.deviceId;
        opt.text = c.label || `Camera ${i+1}`;
        cameraSelect.appendChild(opt);
      });
    }
  }catch(e){
    console.warn('enumerateDevices 실패', e);
  }
}

cameraSelect.addEventListener('change', async ()=>{
  const id = cameraSelect.value;
  await startCamera(id);
});

async function startCamera(deviceId=null){
  // 기존 스트림 정리
  try{ if(video.srcObject) stopStreamTracks(video.srcObject); } catch(e){ console.warn(e); }
  let constraints;
  if(deviceId){
    constraints = { video: { deviceId: { exact: deviceId } }, audio:false };
  } else {
    constraints = { video: { facingMode: { ideal: 'environment' } }, audio:false };
  }
  try{
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await new Promise(r=> video.onloadedmetadata = r);
    overlay.width = video.videoWidth; overlay.height = video.videoHeight;
    // 카메라 라벨 업데이트
    await enumerateCameras();
  }catch(err){
    console.error('카메라 시작 실패', err);
    alert('카메라 접근에 실패했습니다. (HTTPS 환경 및 브라우저 권한 확인)\n앱 WebView에서는 추가 설정이 필요합니다.');
  }
}

/* -------------------------
   모델 로딩 및 Tesseract 초기화
   ------------------------- */
async function loadModel(){
  model = await cocoSsd.load();
  console.log('COCO-SSD 로드 완료');
}

// Tesseract 워커 초기화 (eng+kor 시도)
async function ensureTesseract(){
  if(tesseractWorker) return;
  tesseractWorker = Tesseract.createWorker({
    logger: m => { /* 필요시 상태 표시 가능 */ }
  });
  await tesseractWorker.load();
  // 한국어 인식을 위해 'kor' 로드 시도 (무겁습니다). 실패해도 영문+숫자 fallback 시도.
  try{
    await tesseractWorker.loadLanguage('eng+kor');
    await tesseractWorker.initialize('eng+kor');
  }catch(e){
    console.warn('kor 로드 실패, eng만 로드합니다.', e);
    await tesseractWorker.loadLanguage('eng');
    await tesseractWorker.initialize('eng');
  }
  // whitelist: 숫자, 영문, 한글 (대역문자 일부는 허용)
  await tesseractWorker.setParameters({
    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789가나다라마바사아자차카타파하거너더러머버서어저초코토포호익' // 일부만 기입 (tessedit_char_whitelist는 환경에 따라 제한적)
  });
  console.log('Tesseract worker 준비됨');
}

/* -------------------------
   OCR 전처리: crop -> 그레이스케일 -> 대비 -> 이진화 -> 확대
   ------------------------- */
function preprocessCropCanvas(srcCanvas){
  const w0 = srcCanvas.width, h0 = srcCanvas.height;
  const targetW = Math.max(300, Math.round(w0 * 2));
  const targetH = Math.round(targetW * (h0 / w0));
  const c = document.createElement('canvas'); c.width = targetW; c.height = targetH;
  const g = c.getContext('2d');
  // 원본 확대
  g.drawImage(srcCanvas, 0, 0, targetW, targetH);
  // 픽셀 처리
  const id = g.getImageData(0,0,targetW,targetH);
  const data = id.data;
  const contrast = 1.6;
  const thr = 120;
  for(let i=0;i<data.length;i+=4){
    const r = data[i], gg = data[i+1], b = data[i+2];
    let gray = 0.2126*r + 0.7152*gg + 0.0722*b;
    gray = ((gray - 128) * contrast) + 128;
    const val = (gray > thr) ? 255 : 0;
    data[i] = data[i+1] = data[i+2] = val;
  }
  g.putImageData(id, 0, 0);
  return c;
}

/* -------------------------
   번호판 OCR 수행 (각 차량 ID 별 1초 스로틀)
   - 한국 번호판 정규식 필터링 적용
   ------------------------- */
async function ocrPlateForObject(id, bbox){
  const obj = tracker.objects.get(id);
  if(!obj) return;
  const now = performance.now();
  if(now - obj.lastOcrTime < 1000) return; // 1초마다 시도
  obj.lastOcrTime = now;
  if(bbox[2] < 80 || bbox[3] < 24) return;

  // 후보 영역: 하단 55% ~ 90% (경우에 따라 조절)
  const sx = Math.max(0, Math.round(bbox[0]));
  const sw = Math.min(video.videoWidth - sx, Math.round(bbox[2]));
  const sy = Math.max(0, Math.round(bbox[1] + bbox[3]*0.55));
  const sh = Math.min(video.videoHeight - sy, Math.max(16, Math.round(bbox[3]*0.35)));
  if(sw <= 0 || sh <= 0) return;

  // crop
  const crop = document.createElement('canvas');
  crop.width = sw; crop.height = sh;
  const g = crop.getContext('2d');
  g.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);

  // 전처리
  const prep = preprocessCropCanvas(crop);

  // 시각 피드백: 박스 깜박
  ctx.strokeStyle = '#ff9'; ctx.lineWidth = 2; ctx.strokeRect(sx, sy, sw, sh);

  // Tesseract 준비
  try{
    if(!tesseractWorker) await ensureTesseract();
  }catch(e){
    console.warn('Tesseract 준비 실패', e);
    return;
  }
  if(ocrBusy) return;
  ocrBusy = true;
  try{
    const { data: { text } } = await tesseractWorker.recognize(prep);
    let clean = (text || '').replace(/\s+/g,'').replace(/[^0-9A-Za-z가-힣]/g,'').trim();
    // 한글을 잘못 인식한 경우 라틴문자→한글로 매핑 시도 (간단 heuristic)
    // 예: 'A'가 '가'로 보일 가능성 — 여기선 변환하지 않음(복잡). 우선 정규식으로 필터링.
    // 한국형 번호판 패턴: 2~3숫자 + 한글 1자 + 4숫자  -> examples: 12가3456 or 123가4567
    const korPattern = /^\d{2,3}[가-힣]\d{4}$/;
    if(korPattern.test(clean)){
      // 유효한 번호판
      obj.plateText = clean;
      const entry = { time: new Date().toLocaleString(), plate: clean, id };
      plateLog.unshift(entry);
      if(plateLog.length > 5) plateLog.pop();
      updatePlateUI();
      detectionsHistory.push(`${entry.time} | ID${id} | ${clean}`);
    } else {
      // 시도: 일부 케이스에서 숫자만 뽑아 포맷 맞추기 (예: '12KA3456' 같은 경우)
      // 여기선 단순히 숫자/한글 포함 결과가 없으면 무시
      // (추가 고급 후처리가 필요하면 더 구현 가능)
    }
  }catch(e){
    console.warn('OCR 에러', e);
  }finally{
    ocrBusy = false;
  }
}

/* -------------------------
   UI 업데이트: plate list
   ------------------------- */
function updatePlateUI(){
  plateListUl.innerHTML = '';
  plateLog.forEach(item=>{
    const li = document.createElement('li');
    li.textContent = `${item.time} | ID${item.id} | ${item.plate}`;
    plateListUl.appendChild(li);
  });
}

/* -------------------------
   거리 측정 (근사, 정수 m)
   - 우선 방식: 캘리브레이션이 있으면 focalPix 사용
   - 없으면 fallback: distance = Math.round(DEFAULT_K / bboxHeight)
   - 캘리브레이션 계산: focalPix = (pixelHeight_at_knownDistance * knownDistance) / realHeight
   ------------------------- */
function estimateDistanceMeters(bbox){
  const bboxH = bbox[3];
  if(!bboxH || bboxH <= 0) return null;
  if(focalPix){
    const carRealHeight = parseFloat(carHeightInput.value) || 1.5;
    const dist = (carRealHeight * focalPix) / bboxH;
    return Math.max(1, Math.round(dist)); // 정수 m
  } else {
    const dist = DEFAULT_K / bboxH;
    return Math.max(1, Math.round(dist));
  }
}

/* 캘리브레이션: 사용자가 기준거리(미터)를 입력하고 캡처하면 focalPix 계산
   알고리즘:
     - 화면에서 가장 큰 차량 bbox를 사용 (사용자가 기준 차량을 중앙에 두고 누르도록 안내)
     - focalPix = (pixelHeight_known * knownDistance) / realCarHeight
*/
calibrateBtn.addEventListener('click', async ()=>{
  const knownDistance = parseFloat(knownDistanceInput.value);
  const realHeight = parseFloat(carHeightInput.value) || 1.5;
  if(!knownDistance || knownDistance <= 0){ alert('기준 거리를 올바르게 입력해주세요'); return; }
  // 현재 트래커에서 가장 큰 차량 bbox 선택
  let largest = null, largestArea = 0;
  for(const [id,obj] of tracker.objects){
    const [x,y,w,h] = obj.bbox;
    const area = w*h;
    if(area > largestArea){ largestArea = area; largest = obj; }
  }
  if(!largest){ alert('캘리브레이션할 차량이 화면에 없습니다. 기준 차량을 중앙에 놓고 다시 시도하세요.'); return; }
  const pixelH = largest.bbox[3];
  // focalPix 계산
  focalPix = (pixelH * knownDistance) / realHeight;
  alert(`캘리브레이션 완료\nfocalPix = ${focalPix.toFixed(2)} (이 값이 저장되어 거리 계산에 사용됩니다)`);
});

/* -------------------------
   drawPredictions: 박스/라벨 그리기 + 트래커 업데이트 + 거리표시
   ------------------------- */
function drawPredictions(predictions){
  overlay.width = video.videoWidth;
  overlay.height = video.videoHeight;
  ctx.clearRect(0,0,overlay.width, overlay.height);

  const rects = [];
  const visible = new Set();
  let vehicleCount = 0;

  predictions.forEach(pred=>{
    if(pred.score < Number(thresholdInput.value)) return;
    // 기본박스
    ctx.strokeStyle = '#00FFFF';
    ctx.lineWidth = 2;
    ctx.strokeRect(...pred.bbox);

    const label = `${pred.class} ${(pred.score*100).toFixed(0)}%`;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    const textW = ctx.measureText(label).width + 8;
    const textH = 18;
    ctx.fillRect(pred.bbox[0], pred.bbox[1]-textH, textW, textH);
    ctx.fillStyle = '#00FFFF';
    ctx.fillText(label, pred.bbox[0]+4, pred.bbox[1]-4);

    visible.add(pred.class);

    if(pred.class === 'car' || pred.class === 'truck' || pred.class === 'bus'){
      rects.push(pred.bbox);
      vehicleCount++;
    }
  });

  detectedListDiv.textContent = Array.from(visible).join(', ') || '(감지된 객체 없음)';
  vehicleCountSpan.textContent = String(vehicleCount);

  // 트래커 업데이트
  const objects = tracker.update(rects);

  // 각 트래킹 객체에 대해 표시
  for(const [id,obj] of objects){
    const [x,y,w,h] = obj.bbox;
    if(showIDCheckbox.checked){
      ctx.strokeStyle = '#FFCC00'; ctx.lineWidth = 3; ctx.strokeRect(x,y,w,h);
      const idLabel = `차량 ID ${id}`;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const tw = ctx.measureText(idLabel).width + 8; const th = 18;
      ctx.fillRect(x, y-th, tw, th);
      ctx.fillStyle = '#FFCC00'; ctx.fillText(idLabel, x+4, y-4);
    }
    // 번호판 텍스트가 있으면 박스 아래에 표시
    if(obj.plateText){
      const txt = `번호판: ${obj.plateText}`;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const wtxt = ctx.measureText(txt).width + 8; const htxt = 18;
      ctx.fillRect(x+4, y+h+4, wtxt, htxt);
      ctx.fillStyle = '#ffd66b'; ctx.fillText(txt, x+8, y+h+18);
    }
    // 거리 계산: 차량이 인식된 경우만 계산하여 정수 m으로 표기
    const dist = estimateDistanceMeters(obj.bbox);
    if(dist){
      const dtxt = `거리: ${dist} m`;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const wd = ctx.measureText(dtxt).width + 8; const hd = 18;
      ctx.fillRect(x + w - wd - 6, y - hd - 6, wd, hd);
      ctx.fillStyle = '#9ff'; ctx.fillText(dtxt, x + w - wd - 2, y - 4);
      // 로그에도 추가 (실시간으로 계속 추가하면 로그가 과도하므로 짧게 한 번만 추가)
      // 대신 detectionsHistory에 기록
      detectionsHistory.push(`${new Date().toLocaleString()} | ID${id} | distance ${dist} m`);
    }
    // 번호판 모드가 켜지면 OCR 시도 (비동기)
    if(plateModeCheckbox.checked){
      ocrPlateForObject(id, obj.bbox).catch(e=>console.warn(e));
    }
  }

  // fps 표시 (rough)
  fpsDisplay.textContent = (1000 / Math.max(1, performance.now() - lastFrameTime)).toFixed(1);
}

/* -------------------------
   탐지 루프
   ------------------------- */
async function detectLoop(timestamp){
  requestAnimationFrame(detectLoop);
  const fpsLimit = Number(fpsLimitInput.value) || 10;
  if(timestamp - lastFrameTime < 1000 / fpsLimit) return;
  lastFrameTime = timestamp;
  if(!model) return;
  if(video.readyState < 2) return;
  let predictions = [];
  try{
    predictions = await model.detect(video);
  }catch(e){
    console.warn('detect error', e);
    return;
  }
  drawPredictions(predictions);
}

/* -------------------------
   버튼 동작: 스냅샷/다운로드/초기화
   ------------------------- */
snapshotBtn.addEventListener('click', ()=>{
  const name = `snapshot_${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
  const temp = document.createElement('canvas'); temp.width = overlay.width; temp.height = overlay.height;
  const g = temp.getContext('2d');
  g.drawImage(video, 0, 0, temp.width, temp.height);
  g.drawImage(overlay, 0, 0, temp.width, temp.height);
  const url = temp.toDataURL('image/png');
  const a = document.createElement('a'); a.href = url; a.download = name; a.click();
});

downloadDetectionsBtn.addEventListener('click', ()=>{
  if(detectionsHistory.length === 0){ alert('탐지 로그가 비어있습니다.'); return; }
  const now = new Date().toISOString().replace(/[:.]/g,'-');
  const name = `detections_${now}.txt`;
  downloadTextFile(name, detectionsHistory.join('\n'));
});

downloadPlateLogBtn.addEventListener('click', ()=>{
  if(plateLog.length === 0){ alert('번호판 로그가 비어있습니다.'); return; }
  const now = new Date().toISOString().replace(/[:.]/g,'-');
  const name = `plate_log_${now}.txt`;
  const lines = plateLog.slice().reverse().map(e => `${e.time} | ID${e.id} | ${e.plate}`);
  downloadTextFile(name, lines.join('\n'));
});

clearPlatesBtn.addEventListener('click', ()=>{
  plateLog.length = 0;
  for(const [id,obj] of tracker.objects){ obj.plateText = null; }
  updatePlateUI();
});

/* -------------------------
   초기화: 카메라 나열, 카메라 시작, 모델 로드, 루프 시작
   ------------------------- */
async function init(){
  await enumerateCameras();
  await startCamera();
  await loadModel();
  requestAnimationFrame(detectLoop);
}
init();

/* -------------------------
   페이지 종료 시 정리
   ------------------------- */
window.addEventListener('beforeunload', async ()=>{
  if(tesseractWorker){
    try{ await tesseractWorker.terminate(); }catch(e){}
  }
  if(video.srcObject) stopStreamTracks(video.srcObject);
});

/* ============================
   주의사항 및 AppInventor(WebView) 관련 팁:
   1) 모바일에서 카메라 선택 후 권한창이 뜨고 재시작되는 현상은 일부 기기/브라우저의 내부 동작입니다.
      - 가능한 해결: HTTPS 환경에서 실행(GitHub Pages 권장), 또는 WebView 설정에서 권한 처리를 네이티브로 직접 구현.
   2) AppInventor의 WebView는 기본적으로 getUserMedia를 지원하지 않을 수 있습니다.
      - Android 네이티브 WebView 사용 시 WebChromeClient.onPermissionRequest 에서 grant 해주어야 합니다.
   3) Tesseract의 'kor' 로드는 메모리/CPU를 많이 사용합니다. 모바일 성능/발열 이슈가 있다면
      - 번호판 모드(plateMode)를 필요할 때만 켜서 사용하거나
      - 서버 기반 ANPR / 전용 YOLO-ANPR 모델 + 서버 OCR 사용을 권장합니다.
   ============================ */

</script>
</body>
</html>
