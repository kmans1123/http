<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>지능형 CCTV — 객체/차량 추적 + 번호판(ANPR) 모드</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- TensorFlow COCO-SSD (객체 탐지) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.9.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
  <!-- Tesseract.js (OCR) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>

  <style>
    :root{--bg:#0b1220;--panel:#0f1a26;--accent:#00ffd6;--muted:#9fb;}
    body{margin:0;font-family:Arial,Helvetica,sans-serif;background:linear-gradient(135deg,#08121a,#0d2130);color:#e6f2f8}
    .container{display:flex;gap:12px;padding:12px;align-items:flex-start;justify-content:center;}
    #viewer{position:relative;background:#000;border-radius:8px;overflow:hidden;box-shadow:0 8px 24px rgba(0,0,0,0.6)}
    video{display:block;max-width:92vw;height:auto;}
    canvas{position:absolute;left:0;top:0;pointer-events:none;}
    .panel{width:360px;background:var(--panel);padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
    .panel h3{margin:0 0 8px 0;color:var(--accent)}
    label{display:block;margin:8px 0;font-size:14px}
    select,input[type=number],button{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:#081824;color:#e6f2f8}
    .row{display:flex;gap:8px}
    .row > *{flex:1}
    .small{width:auto;padding:6px}
    .info{font-size:13px;color:var(--muted);margin-top:8px}
    ul{padding-left:18px;margin:8px 0}
    .plate-item{color:#ffd66b;font-weight:700}
    .log-buttons{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .note{font-size:12px;color:#9fb;margin-top:8px}
  </style>
</head>
<body>
  <div style="text-align:center;padding:10px 0">
    <h2 style="margin:6px 0;color:#bfefff">지능형 CCTV — 객체 인식 · 차량 추적 · 번호판 모드</h2>
    <div style="max-width:1100px;margin:0 auto;color:#9fb">모든 기능은 브라우저(HTTPS 권장)에서 동작합니다. (앱 내 WebView는 추가 설정 필요)</div>
  </div>

  <div class="container">
    <!-- 비디오 뷰어 -->
    <div id="viewer">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="overlay"></canvas>
    </div>

    <!-- 컨트롤 패널 -->
    <div class="panel" id="panel">
      <h3>설정</h3>

      <!-- 카메라 선택 -->
      <label>카메라 선택:
        <select id="cameraSelect"></select>
      </label>

      <!-- 컨피던스 -->
      <label>신뢰도 임계값:
        <input id="threshold" type="number" min="0" max="1" step="0.05" value="0.5">
      </label>

      <!-- FPS 설정 -->
      <label>FPS 제한:
        <input id="fpsLimit" type="number" min="1" max="30" step="1" value="12">
      </label>

      <!-- ID 표시 토글 -->
      <label><input type="checkbox" id="showVehicleID" checked> 차량 ID 표시</label>

      <!-- 번호판 모드 켜기 -->
      <label><input type="checkbox" id="plateMode"> 번호판 모드 사용 (ANPR)</label>

      <!-- 스냅샷 -->
      <label><button id="snapshotBtn">스냅샷 저장 (PNG)</button></label>

      <div class="row">
        <button id="downloadDetectionsBtn" class="small">탐지 로그 다운로드(.txt)</button>
        <button id="clearPlatesBtn" class="small">번호판 목록 초기화</button>
      </div>

      <div class="info">
        FPS: <span id="fpsDisplay">0</span> |
        화면내 차량: <span id="vehicleCount">0</span>
      </div>

      <h3 style="margin-top:12px">인식된 물체(화면에 바로 표시됨)</h3>
      <div id="detectedList" style="min-height:48px;color:#dff; font-size:14px"></div>

      <h3 style="margin-top:12px">번호판 인식 결과 (최대 5개)</h3>
      <ul id="plateList"></ul>

      <div class="log-buttons">
        <button id="downloadPlateLogBtn">번호판 로그 다운로드(.txt)</button>
        <button id="exportAllDetectionsBtn">탐지 전체 다운로드(.txt)</button>
      </div>

      <div class="note">
        • 모바일에서 카메라 변경시 권한 프롬프트가 뜬 뒤 페이지가 새로고쳐지는 경우: 새로고침 없이 권한을 허용/거부하도록 브라우저 권한 설정을 확인하세요.<br>
        • 앱인벤터 WebView에서 카메라 접근 실패 시: WebView 설정(allowFileAccessFromFileURLs, allowUniversalAccessFromFileURLs) 및 HTTPS 제공 여부를 확인하세요. (하단에 자세한 안내 포함)
      </div>
    </div>
  </div>

<script>
/* =====================================================
   전체 기능 요약 (이 스크립트가 하는 일)
   1) COCO-SSD로 객체 인식 (person, car, 등)
   2) 차량(car/truck/bus) 대상으로 Centroid 추적 (ID 부여)
   3) 화면 위 오버레이에 바로 박스/라벨 표시 (요청하신대로)
   4) 번호판 모드: 차량 하단 영역을 잘라 간단 전처리 후 Tesseract로 OCR (1초 스로틀)
   5) 인식된 번호판 최대 5개 유지, 오래된 것부터 삭제, 로그 .txt 다운로드 가능
   6) 카메라 선택/교체 지원 (스트림 안전하게 중지 후 재생)
   7) 스냅샷 저장, 탐지 리스트/통계 표시
   모든 UI와 주석은 한국어로 작성
   ===================================================== */

/* -----------------------
   전역 DOM 참조
   ----------------------- */
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');

const cameraSelect = document.getElementById('cameraSelect');
const thresholdInput = document.getElementById('threshold');
const fpsLimitInput = document.getElementById('fpsLimit');
const showIDCheckbox = document.getElementById('showVehicleID');
const plateModeCheckbox = document.getElementById('plateMode');
const snapshotBtn = document.getElementById('snapshotBtn');

const fpsDisplay = document.getElementById('fpsDisplay');
const vehicleCountSpan = document.getElementById('vehicleCount');

const detectedListDiv = document.getElementById('detectedList');
const plateListUl = document.getElementById('plateList');

const downloadPlateLogBtn = document.getElementById('downloadPlateLogBtn');
const downloadDetectionsBtn = document.getElementById('downloadDetectionsBtn');
const exportAllDetectionsBtn = document.getElementById('exportAllDetectionsBtn');
const clearPlatesBtn = document.getElementById('clearPlatesBtn');

/* -----------------------
   모델/트래커/상태 변수
   ----------------------- */
let model = null;
class CentroidTracker {
  constructor(maxDisappeared=30, maxDistance=120){
    this.nextObjectID = 0;
    this.objects = new Map(); // id -> {centroid, bbox, disappeared, lastOcrTime, plateText}
    this.maxDisappeared = maxDisappeared;
    this.maxDistance = maxDistance;
  }
  register(centroid, bbox){
    this.objects.set(this.nextObjectID, {centroid, bbox, disappeared:0, lastOcrTime:0, plateText:null, minDistanceObserved:Infinity});
    this.nextObjectID++;
  }
  deregister(id){ this.objects.delete(id); }
  update(rects){
    if(rects.length === 0){
      for(const [id,obj] of this.objects){ obj.disappeared++; if(obj.disappeared > this.maxDisappeared) this.deregister(id); }
      return this.objects;
    }
    const inputCentroids = rects.map(r=>[r[0]+r[2]/2, r[1]+r[3]/2]);
    if(this.objects.size===0){
      rects.forEach((r,i)=>this.register(inputCentroids[i], r));
      return this.objects;
    }
    const objectIDs = Array.from(this.objects.keys());
    const objectCentroids = Array.from(this.objects.values()).map(o=>o.centroid);
    // 거리 행렬
    const D = objectCentroids.map(oc => inputCentroids.map(ic => Math.hypot(oc[0]-ic[0], oc[1]-ic[1])));
    // greedy 매칭 (간단)
    const rows = D.map((row,i)=>({i,min:Math.min(...row)})).sort((a,b)=>a.min-b.min).map(r=>r.i);
    const usedCols=new Set(), usedRows=new Set();
    for(const rIndex of rows){
      const distances = D[rIndex];
      let bestCol=-1,bestDist=Infinity;
      for(let c=0;c<distances.length;c++){ if(usedCols.has(c)) continue; if(distances[c]<bestDist){bestDist=distances[c];bestCol=c;} }
      if(bestCol===-1) continue;
      if(bestDist > this.maxDistance) continue;
      const objectID = objectIDs[rIndex];
      const obj = this.objects.get(objectID);
      obj.centroid = inputCentroids[bestCol];
      obj.bbox = rects[bestCol];
      obj.disappeared = 0;
      // 거리 최소값 갱신 (나중에 '가장 가까웠던' 기록 가능)
      obj.minDistanceObserved = Math.min(obj.minDistanceObserved, bestDist);
      usedCols.add(bestCol); usedRows.add(rIndex);
    }
    // unmatched inputs -> register
    rects.forEach((r,i)=>{ if(!usedCols.has(i)) this.register(inputCentroids[i], r); });
    // unmatched existing -> disappeared++
    objectIDs.forEach((id,idx)=>{ if(!usedRows.has(idx)){ const o=this.objects.get(id); o.disappeared++; if(o.disappeared>this.maxDisappeared) this.deregister(id); } });
    return this.objects;
  }
}
const tracker = new CentroidTracker(20, 120);

let lastFrameTime = 0;
let detectionsHistory = []; // 전체 탐지 로그(텍스트 저장용)
let plateLog = []; // 최근 5개 plate 기록 {time,plate,id}

/* Tesseract 워커 (지연 초기화) */
let tesseractWorker = null;
let ocrBusy = false;

/* -----------------------
   유틸: 안전하게 스트림 중지
   ----------------------- */
function stopStreamedVideoTracks(stream){
  if(!stream) return;
  try{
    stream.getTracks().forEach(track => {
      try { track.stop(); } catch(e) {}
    });
  }catch(e){}
}

/* -----------------------
   카메라 열거 + 선택 관련
   ----------------------- */
async function enumerateCameras(){
  try{
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d=>d.kind==='videoinput');
    cameraSelect.innerHTML = '';
    if(cams.length===0){
      const opt = document.createElement('option'); opt.text = '카메라 없음'; cameraSelect.appendChild(opt);
    } else {
      cams.forEach((c,i)=>{
        const opt = document.createElement('option');
        opt.value = c.deviceId;
        // label은 권한 허용 후에만 채워짐
        opt.text = c.label || `Camera ${i+1}`;
        cameraSelect.appendChild(opt);
      });
    }
  }catch(e){
    console.warn('enumerateDevices 실패', e);
  }
}

cameraSelect.addEventListener('change', async ()=>{
  // 카메라 전환: 기존 트랙을 안전하게 중지하고 새 스트림 요청
  await startCamera(cameraSelect.value);
});

/* -----------------------
   카메라 시작 함수 (deviceId 또는 facingMode)
   - 기존 스트림 정리 -> getUserMedia 호출
   - 권한/오류는 리로드 없이 안내
   ----------------------- */
async function startCamera(deviceId=null){
  // 중복 호출 대비: 중지
  try{
    if(video.srcObject){
      stopStreamedVideoTracks(video.srcObject);
      video.srcObject = null;
    }
  }catch(e){ console.warn(e); }

  // constraints 설정 (deviceId 우선, 없으면 환경(facingMode: environment))
  let constraints = null;
  if(deviceId){
    constraints = { video: { deviceId: { exact: deviceId } }, audio:false };
  } else {
    constraints = { video: { facingMode: { ideal: 'environment' } }, audio:false };
  }

  try{
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await new Promise(r => { video.onloadedmetadata = r; });
    // 카메라 열면 enumerateDevices 다시 호출해서 라벨 업데이트
    await enumerateCameras();
    // canvas 사이즈 동기화
    overlay.width = video.videoWidth;
    overlay.height = video.videoHeight;
  }catch(err){
    console.error('카메라 열기 실패', err);
    alert('카메라 접근에 실패했습니다.\n- 브라우저가 HTTPS인지 확인\n- 앱 내 WebView일 경우 카메라 권한/설정 필요\n(콘솔 메시지 확인 요망)');
  }
}

/* -----------------------
   모델 로드 및 Tesseract 초기화 (지연)
   ----------------------- */
async function loadCocoModel(){
  model = await cocoSsd.load();
  console.log('COCO-SSD 모델 로드 완료');
}

async function ensureTesseract(){
  if(tesseractWorker) return;
  tesseractWorker = Tesseract.createWorker({
    logger: m => { /* 필요시 상태 표시 가능 */ }
  });
  await tesseractWorker.load();
  await tesseractWorker.loadLanguage('eng'); // 한국 번호판 등 지역에 따라 언어 다름. 숫자+영문 위주면 'eng' 사용
  await tesseractWorker.initialize('eng');
  await tesseractWorker.setParameters({
    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-'
  });
  console.log('Tesseract 준비 완료');
}

/* -----------------------
   OCR 전처리: crop -> 그레이스케일 -> 대비 증폭 -> 이진화 -> 확대
   (Tesseract에 전달하기 전에 이미지 퀄리티를 올리려 시도)
   ----------------------- */
function preprocessPlateCanvas(srcCanvas){
  // srcCanvas: crop된 원본 (작게 들어옴)
  const w0 = srcCanvas.width, h0 = srcCanvas.height;
  // target width: 최소 300px (확대)
  const targetW = Math.max(300, w0*2);
  const targetH = Math.round(targetW * (h0 / w0));
  const c = document.createElement('canvas');
  c.width = targetW;
  c.height = targetH;
  const g = c.getContext('2d');
  g.drawImage(srcCanvas, 0, 0, targetW, targetH);

  // 이미지데이터 처리 (그레이스케일 + 대비 증폭 + 이진화)
  const id = g.getImageData(0,0,targetW,targetH);
  const data = id.data;
  // simple contrast
  const contrast = 1.5; // 1.0 = 원본, 높일수록 대비 증가
  for(let i=0;i<data.length;i+=4){
    // grayscale
    const r = data[i], gg = data[i+1], b = data[i+2];
    let gray = 0.2126*r + 0.7152*gg + 0.0722*b;
    // contrast adjust around 128
    gray = ((gray - 128) * contrast) + 128;
    // apply thresholding
    const thr = 120; // 임계값: 경험치로 조절
    const val = gray > thr ? 255 : 0;
    data[i] = data[i+1] = data[i+2] = val;
    // keep alpha
  }
  g.putImageData(id,0,0);
  return c;
}

/* -----------------------
   OCR 수행 함수 (각 차량 id별로 1초 스로틀)
   ----------------------- */
async function ocrPlateForObject(id, bbox){
  const obj = tracker.objects.get(id);
  if(!obj) return;
  const now = performance.now();
  if(now - obj.lastOcrTime < 1000) return; // 1초마다 시도
  obj.lastOcrTime = now;

  // bbox 크기 체크 (너무 작으면 스킵)
  if(bbox[2] < 80 || bbox[3] < 24) return;

  // plate candidate 영역: bbox 하단 35% ~ 85% 사이 (경우에 따라 조절)
  const sx = Math.max(0, Math.round(bbox[0]));
  const sw = Math.min(video.videoWidth - sx, Math.round(bbox[2]));
  const sy = Math.max(0, Math.round(bbox[1] + bbox[3]*0.55)); // 하단 시작
  const sh = Math.min(video.videoHeight - sy, Math.max(16, Math.round(bbox[3]*0.35)));

  if(sw <= 0 || sh <= 0) return;

  // crop 현재 프레임에서 영역 잘라 canvas로
  const cropCanvas = document.createElement('canvas');
  cropCanvas.width = sw; cropCanvas.height = sh;
  const g = cropCanvas.getContext('2d');
  g.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);

  // 전처리
  const prep = preprocessPlateCanvas(cropCanvas);

  // 시각 피드백(짧게 박스 표시)
  ctx.strokeStyle = '#ff9';
  ctx.lineWidth = 2;
  ctx.strokeRect(sx, sy, sw, sh);

  // Tesseract 초기화가 아직 안됐으면 초기화
  try{
    if(!tesseractWorker) await ensureTesseract();
  }catch(e){
    console.warn('Tesseract 초기화 실패', e);
    return;
  }

  if(ocrBusy) return; // 단일 OCR 직렬 처리
  ocrBusy = true;
  try{
    const { data: { text } } = await tesseractWorker.recognize(prep);
    const clean = (text || '').replace(/[^A-Z0-9\-]/ig, '').trim();
    if(clean.length >= 3){
      obj.plateText = clean;
      // plateLog에 추가(최대 5개 유지)
      const entry = { time: new Date().toLocaleString(), plate: clean, id };
      plateLog.unshift(entry); // 최근 앞에
      if(plateLog.length > 5) plateLog.pop();
      updatePlateListUI();
      // 전체 탐지 로그에도 추가
      detectionsHistory.push(`${entry.time} | ID${id} | ${clean}`);
    }
  }catch(e){
    console.warn('OCR 오류', e);
  }finally{
    ocrBusy = false;
  }
}

/* -----------------------
   UI 업데이트: plate list
   ----------------------- */
function updatePlateListUI(){
  plateListUl.innerHTML = '';
  plateLog.slice().forEach(entry=>{
    const li = document.createElement('li');
    li.innerHTML = `${entry.time} &nbsp; <span class="plate-item">${entry.plate}</span> (ID ${entry.id})`;
    plateListUl.appendChild(li);
  });
}

/* -----------------------
   감지 루프: 모델로 detect -> draw
   ----------------------- */
async function detectLoop(timestamp){
  requestAnimationFrame(detectLoop);
  // FPS 제한 적용
  const fpsLimit = Number(fpsLimitInput.value) || 12;
  if(timestamp - lastFrameTime < 1000 / fpsLimit) return;
  lastFrameTime = timestamp;

  if(!model) return;
  if(video.readyState < 2) return;

  // 객체 탐지
  let predictions = [];
  try{
    predictions = await model.detect(video);
  }catch(e){
    console.warn('detect error', e);
    return;
  }
  drawPredictions(predictions);
}

/* -----------------------
   drawPredictions: 캔버스에 박스/라벨 그리기 + 트래커 업데이트
   ----------------------- */
function drawPredictions(predictions){
  // 캔버스 크기 동기화
  overlay.width = video.videoWidth;
  overlay.height = video.videoHeight;
  ctx.clearRect(0,0,overlay.width, overlay.height);

  const rects = [];
  const visibleLabels = new Set();
  let vehicleCount = 0;

  predictions.forEach(pred=>{
    if(pred.score < Number(thresholdInput.value)) return;
    // 기본 박스 (모든 객체)
    ctx.strokeStyle = '#00FFFF';
    ctx.lineWidth = 2;
    ctx.strokeRect(...pred.bbox);
    const label = `${pred.class} ${(pred.score*100).toFixed(0)}%`;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    const textW = ctx.measureText(label).width + 8;
    const textH = 18;
    ctx.fillRect(pred.bbox[0], pred.bbox[1]-textH, textW, textH);
    ctx.fillStyle = '#00FFFF';
    ctx.fillText(label, pred.bbox[0]+4, pred.bbox[1]-4);

    visibleLabels.add(pred.class);

    if(pred.class === 'car' || pred.class === 'truck' || pred.class === 'bus'){
      rects.push(pred.bbox);
      vehicleCount++;
    }
  });

  // 감지된 레이블을 별도 텍스트로 보여주기 (화면 밖 리스트 대신)
  detectedListDiv.innerHTML = Array.from(visibleLabels).join(', ') || '(감지된 객체 없음)';

  vehicleCountSpan.textContent = String(vehicleCount);

  // 트래커 업데이트 (차량만)
  const objects = tracker.update(rects);

  // 트래킹 결과 그리기
  for(const [id,obj] of objects){
    const [x,y,w,h] = obj.bbox;
    if(showIDCheckbox.checked){
      ctx.strokeStyle = '#FFCC00';
      ctx.lineWidth = 3;
      ctx.strokeRect(x,y,w,h);
      const idLabel = `차량 ID ${id}`;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const textW = ctx.measureText(idLabel).width + 8;
      const textH = 18;
      ctx.fillRect(x, y-textH, textW, textH);
      ctx.fillStyle = '#FFCC00';
      ctx.fillText(idLabel, x+4, y-4);
    }
    // plateText가 있으면 박스 아래에 표시
    if(obj.plateText){
      const txt = `번호판: ${obj.plateText}`;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const wtxt = ctx.measureText(txt).width + 8;
      const htxt = 18;
      ctx.fillRect(x+4, y+h+4, wtxt, htxt);
      ctx.fillStyle = '#ffd66b';
      ctx.fillText(txt, x+8, y+h+18);
    }

    // 번호판 모드가 켜져 있으면 OCR 시도 (비동기)
    if(plateModeCheckbox.checked){
      // 비동기이므로 에러 무시
      ocrPlateForObject(id, obj.bbox).catch(e=>console.warn(e));
    }
  }

  // FPS 계산 (대략)
  fpsDisplay.textContent = (1000 / Math.max(1, performance.now() - lastFrameTime)).toFixed(1);
}

/* -----------------------
   다운로드 기능: 텍스트 파일 생성
   ----------------------- */
function downloadTextFile(filename, text){
  const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

/* 버튼: 번호판 로그 다운로드(.txt) */
downloadPlateLogBtn.addEventListener('click', ()=>{
  if(plateLog.length===0){ alert('번호판 로그가 비어있습니다.'); return; }
  const now = new Date().toISOString().replace(/[:.]/g,'-');
  const filename = `plate_log_${now}.txt`;
  const lines = plateLog.slice().reverse().map(el => `${el.time} | ${el.id} | ${el.plate}`);
  downloadTextFile(filename, lines.join('\n'));
});

/* 버튼: 전체 탐지(歷史) 다운로드(.txt) */
downloadDetectionsBtn.addEventListener('click', ()=>{
  if(detectionsHistory.length===0){ alert('탐지 로그가 비어있습니다.'); return; }
  const now = new Date().toISOString().replace(/[:.]/g,'-');
  const filename = `detections_${now}.txt`;
  downloadTextFile(filename, detectionsHistory.join('\n'));
});

/* exportAllDetectionsBtn : 동일 기능 (백업용) */
exportAllDetectionsBtn.addEventListener('click', ()=>{
  downloadDetectionsBtn.click();
});

/* clear plates */
clearPlatesBtn.addEventListener('click', ()=>{
  plateLog.length = 0;
  for(const [id,obj] of tracker.objects){ obj.plateText = null; }
  updatePlateListUI();
});

/* snapshot */
snapshotBtn.addEventListener('click', ()=>{
  // snapshot from overlay (video with drawings)
  const d = new Date().toISOString().replace(/[:.]/g,'-');
  const filename = `snapshot_${d}.png`;
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = overlay.width; tempCanvas.height = overlay.height;
  const g = tempCanvas.getContext('2d');
  // draw video then overlay onto temp
  g.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
  g.drawImage(overlay, 0, 0, tempCanvas.width, tempCanvas.height);
  const url = tempCanvas.toDataURL('image/png');
  const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
});

/* -----------------------
   초기화: 카메라 나열 -> 카메라 시작 -> 모델로드 -> 루프 시작
   ----------------------- */
async function init(){
  // 카메라 나열(권한 있으면 라벨 포함)
  await enumerateCameras();
  // 기본 카메라 시작 (deviceId가 있으면 우선 선택)
  await startCamera(); // facingMode: environment 우선
  // 모델 로드
  await loadCocoModel();
  // 탐지 루프 시작
  requestAnimationFrame(detectLoop);
}

/* 페이지 로드 시 init */
init();

/* -----------------------
   AppInventor(또는 WebView) 관련 안내(주석)
   - WebView에서 카메라가 동작하려면:
     1) 앱이 HTTPS의 페이지를 로드하거나, WebView가 getUserMedia를 허용하도록 구성되어야 함.
     2) Android WebView: setWebContentsDebuggingEnabled, WebChromeClient에서 onPermissionRequest 처리
        (예: WebChromeClient#onPermissionRequest에서 grant(request.getResources()))
     3) 일부 WebView는 getUserMedia를 기본적으로 차단함. 이 경우 네이티브 권한 핸들링/설정이 필요.
     4) 임시로 테스트하려면 PC/휴대폰 브라우저(Chrome)에서 GitHub Pages(HTTPS)로 배포 후 실행 권장.
   ----------------------- */

/* -----------------------
   페이지 종료 시 리소스 정리
   ----------------------- */
window.addEventListener('beforeunload', async ()=>{
  if(tesseractWorker){
    try{ await tesseractWorker.terminate(); }catch(e){ console.warn(e); }
  }
  if(video.srcObject){
    stopStreamedVideoTracks(video.srcObject);
  }
});
</script>
</body>
</html>
